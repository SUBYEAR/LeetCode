package com.leetcode.medium.review;

/**
 * 假设你有一个特殊的键盘包含下面的按键：
 *
 * Key 1: (A)：在屏幕上打印一个 'A'。
 *
 * Key 2: (Ctrl-A)：选中整个屏幕。
 *
 * Key 3: (Ctrl-C)：复制选中区域到缓冲区。
 *
 * Key 4: (Ctrl-V)：将缓冲区内容输出到上次输入的结束位置，并显示在屏幕上。
 *
 * 现在，你只可以按键 N 次（使用上述四种按键），请问屏幕上最多可以显示几个 'A'呢？
 *
 * 样例 1:
 *
 * 输入: N = 3
 * 输出: 3
 * 解释:
 * 我们最多可以在屏幕上显示三个'A'通过如下顺序按键：
 * A, A, A
 *  
 *
 * 样例 2:
 *
 * 输入: N = 7
 * 输出: 9
 * 解释:
 * 我们最多可以在屏幕上显示九个'A'通过如下顺序按键：
 * A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V
 *
 * 动态规划【通过】
 * 思路和算法
 *
 * 假设 best[k] 是按键 k 次得到 'A' 的最多数量。
 *
 * 假设 k 次按键后得到了最多数量的 'A'。如果它的最后一步使用加法，则 best[k] = best[k-1] + 1。
 *
 * 如果最后一步使用乘法，且乘 x，x 满足 x < k-1，则 best[k-(x+1)] = best[k-(x+1)] * x。
 *
 * 当 j < k 时，根据 best[0], best[1], ..., best[k-1] 找出计算出最大的 best[k]。
 *
 */
public class LeetCode651 {
    public int maxA(int N) {
        int[] best = new int[N+1];
        for (int k = 1; k <= N; ++k) {
            best[k] = best[k-1] + 1;
            for (int x = 0; x < k-1; ++x)
                best[k] = Math.max(best[k], best[x] * (k-x-1));
        }
        return best[N];
    }
}

//做 2N 次乘法，需要 2N+1 次操作。如果先乘 N 次，再对此时结果乘 2，则一共需要 N+4 次操作。当 N >= 3 时，第二种方式的操作步骤更少。
//
//同样的，做 2N+1 次乘法，需要 2N+2 次操作。可以改为先乘 N+1 次，再对此时结果乘 2，则一共需要 N+5 次操作。当 N>=3 时，第二种方式的操作步骤更少。
//
//结合以上情况，连乘不会超过 5 次。
//
//算法
//
//本方法与 方法一 相同，只是在内部循环中不考虑连乘次数大于 5 的情况。为简便起见，省略本方法代码。

